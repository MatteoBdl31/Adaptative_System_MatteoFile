{% extends "base.html" %}
{% block title %}All Available Trails{% endblock %}
{% block page_class %}all-trails-page{% endblock %}
{% block extra_head %}
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
{% endblock %}
{% block content %}
    <div class="all-trails-container">
        <header class="all-trails-header">
            <h1 class="all-trails-header__title">ğŸ—ºï¸ All Available Trails</h1>
            <p class="all-trails-header__subtitle">Explore our complete collection of hiking trails with real-time weather forecasts</p>
            <nav class="all-trails-header__nav">
                <a href="{{ url_for('demo') }}" class="btn btn-secondary">ğŸ¯ Demo</a>
                <a href="{{ url_for('admin_rules') }}" class="btn btn-secondary">âš™ï¸ Admin Rules</a>
            </nav>
        </header>

        <div class="all-trails-content">
        <div class="filter-section">
            <h3>Filter Trails & Weather</h3>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--space-lg);">
                <div class="filter-group">
                    <label for="hike-start-date">ğŸ—“ï¸ Hike Start Date</label>
                    <input type="date" id="hike-start-date" value="{{ hike_start_date }}">
                </div>
                <div class="filter-group">
                    <label for="hike-end-date">ğŸ—“ï¸ Hike End Date</label>
                    <input type="date" id="hike-end-date" value="{{ hike_end_date }}">
                </div>
                <div class="filter-group">
                    <label for="filter-difficulty">â›°ï¸ Difficulty</label>
                    <select id="filter-difficulty">
                        <option value="">All Levels</option>
                        <option value="easy">Easy (â‰¤3)</option>
                        <option value="medium">Medium (4-6)</option>
                        <option value="hard">Hard (â‰¥7)</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="filter-landscape">ğŸï¸ Landscape</label>
                    <select id="filter-landscape">
                        <option value="">All Landscapes</option>
                        <option value="lake">ğŸ”ï¸ Lake</option>
                        <option value="forest">ğŸŒ² Forest</option>
                        <option value="peaks">â›°ï¸ Peaks</option>
                        <option value="mountain">ğŸ—» Mountain</option>
                        <option value="alpine">ğŸ”ï¸ Alpine</option>
                        <option value="river">ğŸï¸ River</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="filter-type">ğŸš¶ Trail Type</label>
                    <select id="filter-type">
                        <option value="">All Types</option>
                        <option value="loop">ğŸ”„ Loop</option>
                        <option value="one_way">â¡ï¸ One Way</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="filter-distance">ğŸ“ Max Distance (km)</label>
                    <input type="number" id="filter-distance" placeholder="No limit" min="0" step="0.5">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-md); margin-top: var(--space-lg);">
                <button onclick="updateWeather()" class="btn-secondary">ğŸŒ¦ï¸ Update Weather</button>
                <button onclick="applyFilters()" class="btn-primary">ğŸ” Apply Filters</button>
                <button onclick="clearFilters()" class="btn-secondary">âœ–ï¸ Clear Filters</button>
            </div>
        </div>

        <div class="connection-status" id="connection-status" style="display: none;">
            <span id="connection-indicator">ğŸ“¶</span>
            <span id="connection-text">Detecting connection...</span>
        </div>

        <div class="view-toggle">
            <button onclick="showView('map')" id="btn-map" class="active">
                ğŸ—ºï¸ Map View
            </button>
            <button onclick="showView('list')" id="btn-list">
                ğŸ“‹ List View
            </button>
            <button onclick="showView('cards')" id="btn-cards" style="display: none;">
                ğŸƒ Card View
            </button>
        </div>

        <!-- Map View -->
        <div id="map-view" class="view-section active">
            <h2>ğŸ—ºï¸ Trail Locations on Map</h2>
            <p style="text-align: center; color: var(--color-text-secondary); margin-bottom: var(--space-lg);">
                Explore all available trails on an interactive map. Click on markers to see trail details.
            </p>
            <div id="trails-map"></div>
        </div>

        <!-- Card View (for strong connection) -->
        <div id="cards-view" class="view-section">
            <h2>ğŸƒ All Trails ({{ trails|length }})</h2>
            <p style="text-align: center; color: var(--color-text-secondary); margin-bottom: var(--space-xl);">
                Browse trails with interactive mini-maps. Perfect for exploring details at a glance.
            </p>
            <div class="trails-card-view" id="trails-cards">
                {% for trail in trails %}
                <div class="trail-card-with-map" data-difficulty="{{ trail.difficulty }}" 
                     data-landscape="{{ trail.landscapes }}" data-type="{{ trail.trail_type }}"
                     data-distance="{{ trail.distance }}" data-trail-id="{{ trail.trail_id }}"
                     data-lat="{{ trail.latitude }}" data-lon="{{ trail.longitude }}"
                     data-coordinates="{% if trail.coordinates %}{{ trail.coordinates|tojson }}{% else %}null{% endif %}">
                    <div class="trail-card-map-container">
                        <div class="trail-mini-map" id="mini-map-{{ trail.trail_id }}"></div>
                    </div>
                    <div class="trail-card-content">
                        <h3>{{ trail.name }}</h3>
                        <div class="trail-stats">
                            <span class="difficulty-badge difficulty-{{ 'easy' if trail.difficulty <= 3 else 'medium' if trail.difficulty <= 6 else 'hard' }}">
                                {% if trail.difficulty <= 3 %}âœ… Easy
                                {% elif trail.difficulty <= 6 %}âš ï¸ Medium
                                {% else %}ğŸ”´ Hard{% endif %}
                            </span>
                            <span>ğŸ“ {{ trail.distance }} km</span>
                            <span>â±ï¸ {{ trail.duration|format_duration }}</span>
                            <span>â›°ï¸ {{ trail.elevation_gain }}m â†‘</span>
                            {% if trail.forecast_weather %}
                                <span class="badge" title="Weather forecast for {{ hike_start_date|format_date }}">
                                    {% if trail.forecast_weather == 'sunny' %}â˜€ï¸
                                    {% elif trail.forecast_weather == 'cloudy' %}â˜ï¸
                                    {% elif trail.forecast_weather == 'rainy' %}ğŸŒ§ï¸
                                    {% elif trail.forecast_weather == 'snowy' %}â„ï¸
                                    {% elif trail.forecast_weather == 'storm_risk' %}â›ˆï¸
                                    {% else %}ğŸŒ¤ï¸{% endif %}
                                    {{ trail.forecast_weather|title }}
                                </span>
                            {% else %}
                                <span class="badge" style="opacity: 0.5;" title="Weather data unavailable">ğŸŒ¤ï¸ N/A</span>
                            {% endif %}
                        </div>
                        <p class="trail-description">{{ trail.description }}</p>
                        <div class="trail-features">
                            <div class="landscapes">
                                {% for landscape in trail.landscapes.split(',') %}
                                <span class="landscape-tag">ğŸï¸ {{ landscape.strip() }}</span>
                                {% endfor %}
                            </div>
                            <div class="accessibility">
                                {% if trail.accessibility %}
                                <span class="access-tag">â™¿ {{ trail.accessibility.split(',')[0] }}</span>
                                {% endif %}
                            </div>
                        </div>
                        <div style="margin-top: var(--space-md); display: flex; gap: var(--space-lg); color: var(--color-text-secondary); font-size: var(--font-size-sm);">
                            <span><strong>Type:</strong> {{ trail.trail_type.replace('_', ' ').title() }}</span>
                            <span><strong>Popularity:</strong> â­ {{ trail.popularity }}/10</span>
                        </div>
                        {% if trail.latitude and trail.longitude %}
                        <a href="#" onclick="showTrailOnMap({{ trail.latitude }}, {{ trail.longitude }}); return false;" 
                           class="btn-primary" style="margin-top: var(--space-md); width: 100%;">ğŸ“ View on Map</a>
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- List View (for weak connection) -->
        <div id="list-view" class="view-section">
            <h2>ğŸ“‹ All Trails ({{ trails|length }})</h2>
            <p style="text-align: center; color: var(--color-text-secondary); margin-bottom: var(--space-xl);">
                A lightweight list view optimized for slower connections. All essential trail information at your fingertips.
            </p>
            <div class="trails-list-view" id="trails-list">
                {% for trail in trails %}
                <div class="trail-card" data-difficulty="{{ trail.difficulty }}" 
                     data-landscape="{{ trail.landscapes }}" data-type="{{ trail.trail_type }}"
                     data-distance="{{ trail.distance }}" data-trail-id="{{ trail.trail_id }}">
                    {% if trail.latitude and trail.longitude %}
                    <div class="trail-image-placeholder">
                        ğŸï¸
                    </div>
                    {% endif %}
                    <div class="trail-content">
                        <h3>{{ trail.name }}</h3>
                        <div class="trail-stats">
                            <span class="difficulty-badge difficulty-{{ 'easy' if trail.difficulty <= 3 else 'medium' if trail.difficulty <= 6 else 'hard' }}">
                                {% if trail.difficulty <= 3 %}âœ… Easy
                                {% elif trail.difficulty <= 6 %}âš ï¸ Medium
                                {% else %}ğŸ”´ Hard{% endif %}
                            </span>
                            <span>ğŸ“ {{ trail.distance }} km</span>
                            <span>â±ï¸ {{ trail.duration|format_duration }}</span>
                            <span>â›°ï¸ {{ trail.elevation_gain }}m â†‘</span>
                            {% if trail.forecast_weather %}
                                <span class="badge" title="Weather forecast for {{ hike_start_date|format_date }}">
                                    {% if trail.forecast_weather == 'sunny' %}â˜€ï¸
                                    {% elif trail.forecast_weather == 'cloudy' %}â˜ï¸
                                    {% elif trail.forecast_weather == 'rainy' %}ğŸŒ§ï¸
                                    {% elif trail.forecast_weather == 'snowy' %}â„ï¸
                                    {% elif trail.forecast_weather == 'storm_risk' %}â›ˆï¸
                                    {% else %}ğŸŒ¤ï¸{% endif %}
                                    {{ trail.forecast_weather|title }}
                                </span>
                            {% else %}
                                <span class="badge" style="opacity: 0.5;" title="Weather data unavailable">ğŸŒ¤ï¸ N/A</span>
                            {% endif %}
                        </div>
                        <p class="trail-description">{{ trail.description }}</p>
                        <div class="trail-features">
                            <div class="landscapes">
                                {% for landscape in trail.landscapes.split(',') %}
                                <span class="landscape-tag">ğŸï¸ {{ landscape.strip() }}</span>
                                {% endfor %}
                            </div>
                            <div class="accessibility">
                                {% if trail.accessibility %}
                                <span class="access-tag">â™¿ {{ trail.accessibility.split(',')[0] }}</span>
                                {% endif %}
                            </div>
                        </div>
                        <div style="margin-top: var(--space-md); display: flex; gap: var(--space-lg); color: var(--color-text-secondary); font-size: var(--font-size-sm);">
                            <span><strong>Type:</strong> {{ trail.trail_type.replace('_', ' ').title() }}</span>
                            <span><strong>Popularity:</strong> â­ {{ trail.popularity }}/10</span>
                        </div>
                        {% if trail.latitude and trail.longitude %}
                        <a href="#" onclick="showTrailOnMap({{ trail.latitude }}, {{ trail.longitude }}); return false;" 
                           class="btn-primary" style="margin-top: var(--space-md);">ğŸ“ View on Map</a>
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
        
        <!-- Scroll to Top Button -->
        <button class="scroll-to-top" id="scroll-to-top" onclick="scrollToTop()">â†‘</button>
        </div>
    </div>
{% endblock %}
{% block extra_scripts %}
    <script>
        // Global variables for map and trails
        var map = null;
        var markers = [];
        var polylines = [];
        var currentTrails = [];
        var connectionStrength = 'strong'; // Default to strong, will be detected
        var miniMaps = {}; // Store mini maps for card view
        
        // Helper function to format duration
        function formatDuration(minutes) {
            if (!minutes) return 'N/A';
            var hours = Math.floor(minutes / 60);
            var mins = minutes % 60;
            if (hours > 0 && mins > 0) {
                return hours + 'h ' + mins + 'm';
            } else if (hours > 0) {
                return hours + 'h';
            } else {
                return mins + 'm';
            }
        }
        
        // Connection detection function
        function detectConnection() {
            return new Promise(function(resolve) {
                // Check if navigator.connection is available (Network Information API)
                if ('connection' in navigator) {
                    var conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    if (conn) {
                        // Use effectiveType if available (Chrome/Edge)
                        if (conn.effectiveType) {
                            var effectiveType = conn.effectiveType;
                            if (effectiveType === 'slow-2g' || effectiveType === '2g') {
                                resolve('weak');
                                return;
                            } else if (effectiveType === '3g') {
                                // For 3g, check downlink speed if available
                                if (conn.downlink !== undefined && conn.downlink < 1.5) {
                                    resolve('weak');
                                    return;
                                }
                                // Otherwise test with a small download
                                testConnectionSpeed().then(function(isFast) {
                                    resolve(isFast ? 'strong' : 'weak');
                                });
                                return;
                            } else {
                                // 4g or better
                                resolve('strong');
                                return;
                            }
                        }
                        // Use downlink if available (Mbps)
                        if (conn.downlink !== undefined) {
                            if (conn.downlink < 0.5) {
                                resolve('weak');
                                return;
                            } else if (conn.downlink < 1.5) {
                                // Test with a small download for borderline cases
                                testConnectionSpeed().then(function(isFast) {
                                    resolve(isFast ? 'strong' : 'weak');
                                });
                                return;
                            } else {
                                resolve('strong');
                                return;
                            }
                        }
                    }
                }
                
                // Fallback: test connection speed with a small download
                testConnectionSpeed().then(function(isFast) {
                    resolve(isFast ? 'strong' : 'weak');
                });
            });
        }
        
        // Test connection speed by downloading a small resource
        function testConnectionSpeed() {
            return new Promise(function(resolve) {
                var startTime = Date.now();
                var timeoutId;
                
                // Try using fetch API for more reliable testing
                if ('fetch' in window) {
                    // Use a small endpoint - try to fetch the current page's HTML head
                    fetch(window.location.href, {
                        method: 'HEAD',
                        cache: 'no-cache'
                    }).then(function(response) {
                        clearTimeout(timeoutId);
                        var endTime = Date.now();
                        var duration = endTime - startTime;
                        // If it takes more than 2 seconds, consider it weak
                        resolve(duration < 2000);
                    }).catch(function() {
                        clearTimeout(timeoutId);
                        // If fetch fails, assume weak connection
                        resolve(false);
                    });
                    
                    // Timeout after 3 seconds
                    timeoutId = setTimeout(function() {
                        resolve(false); // Assume weak if timeout
                    }, 3000);
                } else {
                    // Fallback: assume strong if we can't test
                    // This is safer for user experience
                    resolve(true);
                }
            });
        }
        
        // Initialize connection detection and set default view
        function initializeConnection() {
            detectConnection().then(function(strength) {
                connectionStrength = strength;
                var statusEl = document.getElementById('connection-status');
                var indicatorEl = document.getElementById('connection-indicator');
                var textEl = document.getElementById('connection-text');
                var cardsBtn = document.getElementById('btn-cards');
                
                if (strength === 'weak') {
                    indicatorEl.textContent = 'ğŸ“¶';
                    textEl.textContent = 'Weak connection detected - Using lightweight view';
                    statusEl.style.background = 'rgba(239, 68, 68, 0.2)';
                    statusEl.style.display = 'block';
                    cardsBtn.style.display = 'none';
                    // Ensure list view is shown for weak connection
                    if (!document.getElementById('list-view').classList.contains('active')) {
                        showView('list');
                    }
                } else {
                    indicatorEl.textContent = 'ğŸ“¶';
                    textEl.textContent = 'Strong connection detected - Card view with maps available';
                    statusEl.style.background = 'rgba(34, 197, 94, 0.2)';
                    statusEl.style.display = 'block';
                    cardsBtn.style.display = 'inline-block';
                    // Show card view by default for strong connection
                    showView('cards');
                    // Initialize mini maps after a short delay
                    setTimeout(function() {
                        initializeMiniMaps();
                    }, 500);
                }
            });
        }
        
        // Initialize mini maps for card view
        function initializeMiniMaps() {
            if (typeof L === 'undefined') return;
            
            var cardElements = document.querySelectorAll('.trail-card-with-map');
            cardElements.forEach(function(card) {
                var trailId = card.getAttribute('data-trail-id');
                var lat = parseFloat(card.getAttribute('data-lat'));
                var lon = parseFloat(card.getAttribute('data-lon'));
                var mapContainer = document.getElementById('mini-map-' + trailId);
                
                if (!mapContainer || !lat || !lon) return;
                
                try {
                    var miniMap = L.map('mini-map-' + trailId, {
                        zoomControl: false,
                        attributionControl: false,
                        dragging: false,
                        touchZoom: false,
                        doubleClickZoom: false,
                        scrollWheelZoom: false,
                        boxZoom: false,
                        keyboard: false
                    }).setView([lat, lon], 12);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19
                    }).addTo(miniMap);
                    
                    // Add marker
                    L.marker([lat, lon]).addTo(miniMap);
                    
                    // Add trail path if coordinates available
                    var coordinatesStr = card.getAttribute('data-coordinates');
                    if (coordinatesStr && coordinatesStr !== 'null') {
                        try {
                            var coordinates = JSON.parse(coordinatesStr);
                            if (coordinates && coordinates.coordinates && Array.isArray(coordinates.coordinates)) {
                                var latLngs = coordinates.coordinates.map(function(coord) {
                                    return [coord[1], coord[0]];
                                });
                                L.polyline(latLngs, {
                                    color: '#667eea',
                                    weight: 3,
                                    opacity: 0.7
                                }).addTo(miniMap);
                                
                                // Fit bounds to show the trail
                                var bounds = L.latLngBounds(latLngs);
                                miniMap.fitBounds(bounds, {padding: [10, 10]});
                            }
                        } catch(e) {
                            console.log('Could not parse coordinates for mini map:', e);
                        }
                    }
                    
                    miniMaps[trailId] = miniMap;
                    
                    // Invalidate size after a short delay to ensure proper rendering
                    setTimeout(function() {
                        miniMap.invalidateSize();
                    }, 100);
                } catch(e) {
                    console.error('Error initializing mini map for trail ' + trailId + ':', e);
                }
            });
        }
        
        // Auto-load weather in background (non-blocking)
        function autoLoadWeather() {
            var startDate = document.getElementById('hike-start-date').value;
            
            if (!startDate) {
                return; // Skip if no date
            }
            
            // Show loading indicator in connection status
            var statusEl = document.getElementById('connection-status');
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.innerHTML = '<span id="connection-indicator">â³</span><span id="connection-text">Loading weather forecasts...</span>';
            }
            
            // Collect all trail IDs
            var trailIds = [];
            var trailCards = document.querySelectorAll('[data-trail-id]');
            trailCards.forEach(function(card) {
                var trailId = card.getAttribute('data-trail-id');
                if (trailId) {
                    trailIds.push(trailId);
                }
            });
            
            if (trailIds.length === 0) {
                return;
            }
            
            // Fetch weather data in background
            var apiUrl = '/api/weather/batch?trail_ids=' + trailIds.join(',') + '&date=' + encodeURIComponent(startDate);
            
            fetch(apiUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Weather API request failed');
                    }
                    return response.json();
                })
                .then(function(data) {
                    var weather = data.weather || {};
                    console.log('Auto-loaded weather for ' + Object.keys(weather).length + ' trails in ' + data.elapsed_seconds + 's');
                    
                    // Update weather badges
                    updateWeatherBadges(weather);
                    updateMapWeather(weather);
                    
                    // Hide loading indicator
                    if (statusEl) {
                        setTimeout(function() {
                            statusEl.style.display = 'none';
                        }, 1000);
                    }
                })
                .catch(function(error) {
                    console.error('Error auto-loading weather:', error);
                    // Silently fail - user can manually refresh
                    if (statusEl) {
                        statusEl.style.display = 'none';
                    }
                });
        }
        
        // Wait for DOM and Leaflet to be ready before initializing map
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize connection detection first
            initializeConnection();
            
            // Auto-load weather in background after page loads
            // This doesn't block the page render
            setTimeout(autoLoadWeather, 500);
            
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded!');
                return;
            }
            
            // Check if map container exists
            var mapContainer = document.getElementById('trails-map');
            if (!mapContainer) {
                console.error('Map container not found!');
                return;
            }
            
            // Wait a bit to ensure the container is visible
            setTimeout(function() {
                try {
                    // Check if container is visible
                    var mapView = document.getElementById('map-view');
                    if (mapView && !mapView.classList.contains('active')) {
                        console.log('Map view is hidden, will initialize when shown');
                    }
                    
                    // Initialize map
                    map = L.map('trails-map').setView([45.8, 6.5], 8);
                    
                    // Add OpenStreetMap tiles
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        maxZoom: 19
                    }).addTo(map);
                    
                    // Invalidate map size to ensure it renders properly
                    setTimeout(function() {
                        if (map) {
                            map.invalidateSize();
                            console.log('Map size invalidated');
                        }
                    }, 200);
                    
                    console.log('Map initialized successfully');
                } catch(e) {
                    console.error('Error initializing map:', e);
                    return;
                }
                
                // Continue with trail data processing
                processTrailData();
            }, 100);
            
            function processTrailData() {

                // Trail data from server
                window.trailsData = [
                {% for trail in trails %}
                {% if trail.latitude and trail.longitude %}
                {
                    id: "{{ trail.trail_id }}",
                    name: {{ trail.name|tojson }},
                    lat: {{ trail.latitude }},
                    lon: {{ trail.longitude }},
                    difficulty: {{ trail.difficulty }},
                    distance: {% if trail.distance is not none %}{{ trail.distance }}{% else %}null{% endif %},
                    duration: {{ trail.duration }},
                    elevation: {% if trail.elevation_gain is not none %}{{ trail.elevation_gain }}{% else %}null{% endif %},
                    landscapes: {{ trail.landscapes|tojson }},
                    type: {{ trail.trail_type|tojson }},
                    description: {{ trail.description|tojson }},
                    popularity: {{ trail.popularity }},
                    coordinates: {% if trail.coordinates %}{{ trail.coordinates|tojson }}{% else %}null{% endif %},
                    forecast_weather: {% if trail.forecast_weather %}{{ trail.forecast_weather|tojson }}{% else %}null{% endif %}
                }{% if not loop.last %},{% endif %}
                {% endif %}
                {% endfor %}
            ];

                // Set current trails
                currentTrails = window.trailsData;

                // Parse coordinates from JSON string if needed
                window.trailsData.forEach(function(trail) {
                    if (trail.coordinates) {
                        // If coordinates is a string, parse it
                        if (typeof trail.coordinates === 'string') {
                            try {
                                trail.coordinates = JSON.parse(trail.coordinates);
                            } catch(e) {
                                console.log('Could not parse coordinates for trail ' + trail.id + ':', e);
                                trail.coordinates = null;
                            }
                        }
                    }
                });

                // Initialize map with all trails
                addTrailsToMap(window.trailsData);
            }
        });

        // Add markers for all trails
        function addTrailsToMap(trails) {
            if (!map) {
                console.error('Map not initialized!');
                return;
            }
            
            // Clear existing markers and polylines
            markers.forEach(function(marker) {
                map.removeLayer(marker);
            });
            polylines.forEach(function(polyline) {
                map.removeLayer(polyline);
            });
            markers = [];
            polylines = [];

            var bounds = [];
            trails.forEach(function(trail) {
                // Build weather info for popup
                var weatherInfo = '';
                if (trail.forecast_weather) {
                    var weatherIcon = '';
                    if (trail.forecast_weather === 'sunny') weatherIcon = 'â˜€ï¸';
                    else if (trail.forecast_weather === 'cloudy') weatherIcon = 'â˜ï¸';
                    else if (trail.forecast_weather === 'rainy') weatherIcon = 'ğŸŒ§ï¸';
                    else if (trail.forecast_weather === 'snowy') weatherIcon = 'â„ï¸';
                    else if (trail.forecast_weather === 'storm_risk') weatherIcon = 'â›ˆï¸';
                    else weatherIcon = 'ğŸŒ¤ï¸';
                    
                    weatherInfo = 'Weather: ' + weatherIcon + ' ' + trail.forecast_weather.charAt(0).toUpperCase() + trail.forecast_weather.slice(1) + '<br>';
                }
                
                var marker = L.marker([trail.lat, trail.lon])
                    .addTo(map)
                    .bindPopup(
                        '<strong>' + (trail.name || 'Unnamed Trail') + '</strong><br>' +
                        'Difficulty: ' + (trail.difficulty <= 3 ? 'Easy' : trail.difficulty <= 6 ? 'Medium' : 'Hard') + '<br>' +
                        'Distance: ' + (trail.distance !== null ? trail.distance + ' km' : 'N/A') + '<br>' +
                        'Duration: ' + formatDuration(trail.duration) + '<br>' +
                        'Elevation: ' + (trail.elevation !== null ? trail.elevation + 'm' : 'N/A') + '<br>' +
                        weatherInfo +
                        'â­ ' + trail.popularity + '/10'
                    );
                markers.push(marker);
                bounds.push([trail.lat, trail.lon]);

                // Add trail path if coordinates available
                if (trail.coordinates) {
                    // Parse coordinates if it's still a string
                    var coordData = trail.coordinates;
                    if (typeof coordData === 'string') {
                        try {
                            coordData = JSON.parse(coordData);
                        } catch(e) {
                            console.log('Could not parse coordinates for trail ' + trail.id + ':', e);
                            coordData = null;
                        }
                    }
                    
                    if (coordData && coordData.coordinates && Array.isArray(coordData.coordinates)) {
                        // Convert GeoJSON coordinates [lon, lat] to Leaflet [lat, lon]
                        var latLngs = coordData.coordinates.map(function(coord) {
                            return [coord[1], coord[0]];
                        });
                        
                        var polyline = L.polyline(latLngs, {
                            color: '#667eea',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                        
                        polylines.push(polyline);
                        
                        // Extend bounds to include the entire trail path
                        var polylineBounds = polyline.getBounds();
                        bounds.push(polylineBounds.getSouthWest());
                        bounds.push(polylineBounds.getNorthEast());
                    }
                }
            });

            // Fit map to show all markers
            if (bounds.length > 0) {
                map.fitBounds(bounds, {padding: [50, 50]});
            }
        }

        // Show trail on map (from list view)
        function showTrailOnMap(lat, lon) {
            showView('map');
            if (map) {
                map.setView([lat, lon], 13);
                // Highlight the marker
                markers.forEach(function(marker) {
                    if (Math.abs(marker.getLatLng().lat - lat) < 0.001 && 
                        Math.abs(marker.getLatLng().lng - lon) < 0.001) {
                        marker.openPopup();
                    }
                });
            }
        }

        // View toggle
        function showView(view) {
            document.getElementById('map-view').classList.toggle('active', view === 'map');
            document.getElementById('list-view').classList.toggle('active', view === 'list');
            document.getElementById('cards-view').classList.toggle('active', view === 'cards');
            document.getElementById('btn-map').classList.toggle('active', view === 'map');
            document.getElementById('btn-list').classList.toggle('active', view === 'list');
            document.getElementById('btn-cards').classList.toggle('active', view === 'cards');
            
            // If switching to map view, invalidate map size to ensure it renders
            if (view === 'map' && map) {
                setTimeout(function() {
                    map.invalidateSize();
                }, 100);
            }
            
            // If switching to cards view, initialize mini maps if not already done
            if (view === 'cards' && connectionStrength === 'strong') {
                setTimeout(function() {
                    initializeMiniMaps();
                }, 200);
            }
        }

        // Filter functions
        function applyFilters() {
            var difficultyFilter = document.getElementById('filter-difficulty').value;
            var landscapeFilter = document.getElementById('filter-landscape').value;
            var typeFilter = document.getElementById('filter-type').value;
            var distanceFilter = document.getElementById('filter-distance').value;

            // Get trailsData from the global scope
            var trailsData = currentTrails.length > 0 ? currentTrails : window.trailsData || [];
            
            var filteredTrails = trailsData.filter(function(trail) {
                // Difficulty filter
                if (difficultyFilter === 'easy' && trail.difficulty > 3) return false;
                if (difficultyFilter === 'medium' && (trail.difficulty <= 3 || trail.difficulty > 6)) return false;
                if (difficultyFilter === 'hard' && trail.difficulty <= 6) return false;

                // Landscape filter
                if (landscapeFilter && !trail.landscapes.toLowerCase().includes(landscapeFilter.toLowerCase())) return false;

                // Type filter
                if (typeFilter && trail.type !== typeFilter) return false;

                // Distance filter
                if (distanceFilter && trail.distance !== null && trail.distance > parseFloat(distanceFilter)) return false;

                return true;
            });

            currentTrails = filteredTrails;
            addTrailsToMap(filteredTrails);
            filterList(filteredTrails);
        }

        function filterList(filteredTrails) {
            var trailCards = document.querySelectorAll('.trail-card, .trail-card-with-map');
            var visibleCount = 0;
            
            trailCards.forEach(function(card) {
                var trailId = card.getAttribute('data-trail-id');
                // Check if this trail matches filters
                var difficulty = parseFloat(card.getAttribute('data-difficulty'));
                var landscape = card.getAttribute('data-landscape');
                if (!landscape) landscape = '';
                landscape = landscape.toLowerCase();
                var type = card.getAttribute('data-type');
                var distance = parseFloat(card.getAttribute('data-distance'));

                var difficultyFilter = document.getElementById('filter-difficulty').value;
                var landscapeFilter = document.getElementById('filter-landscape').value;
                var typeFilter = document.getElementById('filter-type').value;
                var distanceFilter = document.getElementById('filter-distance').value;

                var show = true;

                if (difficultyFilter === 'easy' && difficulty > 3) show = false;
                if (difficultyFilter === 'medium' && (difficulty <= 3 || difficulty > 6)) show = false;
                if (difficultyFilter === 'hard' && difficulty <= 6) show = false;
                if (landscapeFilter && !landscape.includes(landscapeFilter.toLowerCase())) show = false;
                if (typeFilter && type !== typeFilter) show = false;
                if (distanceFilter && distance > parseFloat(distanceFilter)) show = false;

                card.style.display = show ? 'block' : 'none';
                if (show) visibleCount++;
            });
            
            // Update count in headers
            updateTrailCount(visibleCount);
        }
        
        function updateTrailCount(count) {
            var headers = document.querySelectorAll('.view-section h2');
            headers.forEach(function(header) {
                // Extract the icon and text
                var text = header.textContent;
                var icon = text.match(/^[^\w\s]+/)[0]; // Get emoji at start
                var baseText = text.replace(/\([^)]+\)/, '').trim(); // Remove old count
                header.textContent = icon + ' All Trails (' + count + ')';
            });
        }

        function clearFilters() {
            document.getElementById('filter-difficulty').value = '';
            document.getElementById('filter-landscape').value = '';
            document.getElementById('filter-type').value = '';
            document.getElementById('filter-distance').value = '';
            currentTrails = window.trailsData || [];
            addTrailsToMap(currentTrails);
            filterList(currentTrails);
            document.querySelectorAll('.trail-card').forEach(function(card) {
                card.style.display = 'block';
            });
        }
        
        // Fetch weather data asynchronously via AJAX (much faster!)
        function updateWeather() {
            var startDate = document.getElementById('hike-start-date').value;
            var endDate = document.getElementById('hike-end-date').value;
            
            if (!startDate) {
                alert('âš ï¸ Please select a start date');
                return;
            }
            
            // Show loading state
            var btn = event.target;
            var originalText = btn.innerHTML;
            btn.innerHTML = 'â³ Loading Weather...';
            btn.disabled = true;
            
            // Collect all trail IDs
            var trailIds = [];
            var trailCards = document.querySelectorAll('[data-trail-id]');
            trailCards.forEach(function(card) {
                var trailId = card.getAttribute('data-trail-id');
                if (trailId) {
                    trailIds.push(trailId);
                }
            });
            
            if (trailIds.length === 0) {
                alert('No trails found to update weather');
                btn.innerHTML = originalText;
                btn.disabled = false;
                return;
            }
            
            // Fetch weather data in parallel via API
            var apiUrl = '/api/weather/batch?trail_ids=' + trailIds.join(',') + '&date=' + encodeURIComponent(startDate);
            
            fetch(apiUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Weather API request failed');
                    }
                    return response.json();
                })
                .then(function(data) {
                    var weather = data.weather || {};
                    console.log('Fetched weather for ' + Object.keys(weather).length + ' trails in ' + data.elapsed_seconds + 's');
                    
                    // Update weather badges in all views
                    updateWeatherBadges(weather);
                    
                    // Update map popup content
                    updateMapWeather(weather);
                    
                    // Show success message
                    btn.innerHTML = 'âœ… Weather Updated!';
                    setTimeout(function() {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                    }, 2000);
                })
                .catch(function(error) {
                    console.error('Error fetching weather:', error);
                    alert('âŒ Failed to fetch weather data. Please try again.');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                });
        }
        
        // Update weather badges in trail cards
        function updateWeatherBadges(weatherData) {
            // Update all trail cards (both list and card views)
            var trailCards = document.querySelectorAll('[data-trail-id]');
            
            trailCards.forEach(function(card) {
                var trailId = card.getAttribute('data-trail-id');
                var weather = weatherData[trailId];
                
                // Find weather badge in this card
                var weatherBadges = card.querySelectorAll('.trail-stats .badge');
                
                weatherBadges.forEach(function(badge) {
                    // Check if this is a weather badge (contains weather emoji)
                    var text = badge.textContent;
                    if (text.includes('â˜€ï¸') || text.includes('â˜ï¸') || text.includes('ğŸŒ§ï¸') || 
                        text.includes('â„ï¸') || text.includes('â›ˆï¸') || text.includes('ğŸŒ¤ï¸') || text.includes('N/A')) {
                        
                        if (weather) {
                            var icon = 'ğŸŒ¤ï¸';
                            var label = weather;
                            
                            if (weather === 'sunny') icon = 'â˜€ï¸';
                            else if (weather === 'cloudy') icon = 'â˜ï¸';
                            else if (weather === 'rainy') icon = 'ğŸŒ§ï¸';
                            else if (weather === 'snowy') icon = 'â„ï¸';
                            else if (weather === 'storm_risk') icon = 'â›ˆï¸';
                            
                            badge.innerHTML = icon + ' ' + label.charAt(0).toUpperCase() + label.slice(1);
                            badge.style.opacity = '1';
                            badge.title = 'Weather forecast';
                        } else {
                            badge.innerHTML = 'ğŸŒ¤ï¸ N/A';
                            badge.style.opacity = '0.5';
                            badge.title = 'Weather data unavailable';
                        }
                    }
                });
            });
        }
        
        // Update weather in map popups
        function updateMapWeather(weatherData) {
            // Note: Map popups are generated dynamically
            // We'll update them when markers are clicked
            // Store weather data globally for map access
            window.currentWeatherData = weatherData;
        }
        
        // Scroll to top functionality
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Show/hide scroll to top button based on scroll position
        window.addEventListener('scroll', function() {
            var scrollBtn = document.getElementById('scroll-to-top');
            if (window.pageYOffset > 300) {
                scrollBtn.classList.add('visible');
            } else {
                scrollBtn.classList.remove('visible');
            }
        });
    </script>
{% endblock %}

